# 2018년 2월 2일 안드로이드 라이트닝 토크

## 1. Dagger2 라이트하게 훑기 : 드라마앤컴퍼니 이승민님
### Dagger를 위한 기본 개념 이해하기
 - Dagger는 Dependencies Injection(의존성 주입) 프레임워크
 - 의존성 주입은? A class가 B class를 의존할 때, B Object 생성을 A에서 하지 않고 외부에서 생성하여 넘겨주는 것
 - 자바 스프링은 그 자체가 DI 프레임워크

 - IOC : Inversion of Control(제어 역전) : Di는 IoC구현방법 중 하나이다.
 - IOC를 구현하는 방법은 템플릿도 있다!

 - DI는 왜 필요할까? : 객체생성을 외부에 위임 -> Constructor Parameter 등의 보일러 플레이트 코드를 제거
 - 보일러 플레이트 코드를 제거하면 뭐가 좋은가?
 - 귀찮지 않다 / 코드를 유연하게 변경할 수 있다 / 

### Dagger 개념 이해하기
 - Dagger를 이루는 중요 개념들 : Inject, Component, Subcomponent, Module, Scope
 - Inject : Component에게 의존성 주입을 요청
 - Component : Module로부터 생성된 의존성 객체를 주입
 - SubComponent : 부모 컴포넌트의 Inner 컴포넌트 : 서브컴포넌트의 모듈로 주입이 실패하면, 부모 컴포넌트 모듈을 검색.
 - 안드로이드에서는 화면의 상속구조가 갖춰져 있는데, 이와 Dagger를 1:1로 매칭할 수 있다.
 - Module : 의존성 객체를 생성
 - Scope : 생성된 객체의 Lifecycle 범위
 - 흐름도 : Inject->Subcomponent->Module->Scope에 있으면 return / 없으면 생성
 - 흐름도 2 : Inject->Subcomponent에서 없음->상위 컴포넌트->Module검색->이후 같음.(아무데서도 못 찾으면 컴파일 에러.)

### 추가 개념
 - Inject 생성자 : 생성자 자체에도 Inject 어노테이션이 쓰일 수 있다.
 - 테스트 객체 : 테스트 객체, 실제 객체를 쉽게 나눌 수 있다.

### 마무리
 - 러닝커브가 높지만, 장점이 크다.
 - 한번에 하려고 하면 어려우니, 호흡을 길게 두고 공부할 것.

### Q&A
 - Q1 : 생성되는 타이밍을 컨트롤 할 수 있는가?
    - A1 : Lazy Class 안에 주입받고 싶은 객체를 넣으면, Lazy Class안에 객체.get()을 하면 주입을 요구함.
 - Q2 : DI/BI라는 개념이 서버쪽에서는 친숙하고, 많이 사용하는 개념인데.. 안드로이드 개발할 때 DI를 쓰면 어떤 장점을 갖는지?
    - A2 : 파라미터의 변경, 클래스 명세의 변경 등에 신속하고 편하게 대응할 수 있다.

## 2. Clean Architecture with socket.io

### Clean Architecture
 - 클린 아키텍처가 뭐게? : 구글에 검색해봐.
 
### 왜 클린 아키텍처를 사용하는가?
 - 내부에 들어갈 수록, 외부의 코드를 모르기 때문에. -> 테스트 용이, 순수한 코드 사용. 상호간 영향력 감소로 유지보수 용이. UI모듈이 독립적으로 분리되어 개선하기 쉬워짐.

### 클린 아키텍처의 규칙
 - 의존성 법칙 : 소프트웨어의 의존성은 항상 내부를 향해야 한다. (안에서는 밖의 코드를 모르게 하라!)

### socket.io
 ### 소켓이란.
 - 클라이언트와 서버의 커넥션이 맺어진 이후, 커넥션이 맺어진 모든 클라이언트들에게 서버가 이벤트를 보낼 수 있음.
 - 이렇게 되면, 스마트폰에서 리퀘스트를 해도 노트북이나 태블릿 등에서 리스폰스를 받을 수 있다.
 
 ### 왜 적용하기 어려운가?
 - 어렵다기 보다는 익숙하지 않기 때문.(restapi에 익숙한 우리들.)
 - socket.io 자체가 커넥트, 디스커넥트, 리커넥트 등을 직접 설정해줘야함.
 - 

 ### 적용 예시
 -


## 3. 뜯어고치기 쉽게 앱 뜯어고치기
 - Realm, Dagger, Rx 도입 시도 : 코드의 90%를 변경해야 하여 시간부족으로 실패.
 - OCR 베타 출시 & 머티리얼 디자인 가이드 적용 
 - 콴다 V2 출시 : 앱을 처음부터 끝까지 새로 작성 -> 선생님 앱 / 학생 앱 분리

 ### V2 출시를 하면서 돌아본 '지속관리 용이한 앱 만들기'
  - 재사용성, 의존성 제거, 모듈화
  - 안드로이드 클린 아키텍처가 도움이 되었다.

  - 최근 AAC Room이 뜨고 있다?
 
 ### 디자인 컴포넌트 정하기
  - 디자인 컴포넌트를 만드는 것을 고려.
  - 디자인 가이드 앱을 만드는 목적 : 안드로이드 기본 컴포넌트를 이해시키자 / 삼성폰과 lg폰 차이를 인지시키자.(특히 색감!) / SDK 버전에 따른 Style의 차이를 인지시키자 / Margin과 Padding을 이해시키자



## 3.

### 안드로이드 8.0의 변화
 - Dex 파일의 크기가 줄었음.
 - Concurrent Compaction 도입. 모든 앱에 세대적 가비지 컬렉션 도입. 가비지 컬렉터 포즈(pause) 타임 감소. 17.5배 성능 향상
 - 루프를 탈 필요가 없는 것들은 알아서 루프를 타지 않음.
 - 벡터라이제이션 도입.
 
### 품질확보
 - 크래시 리포트나 다종 테스트로는 조금 부족하다.(버벅거림 등)
 - 모든 계층을 모니터링 해야 한다.

 #### 메모리 관리
  - 한번 쓰고 말 객체는 WeakReference를 달아라.
  - 안드로이드 5.0부터 작은 객체와 큰 객체를 구분하여 저장함.
  - GC가 한번 동작하면, 1세대에서 많은 것들이 사라짐.
  - 안드로이드 L부터 gc전략 추가, Foreground / Background GC로 구성.
  - 왜 나눴을까? Foreground는 화면 등을 담당. 빠른 정리가 중요.
  - Oreo부터 Concurrent Compaction이 도입되는 이유? : 앱사이즈 감소, 멀티코어 디바이스 확대.
  - 다만, 제조사가 언제든 다른 옵션을 켤 수 있다.
  - 메모리 사용 지표 : MemFree보다 MemAvailable을 이용하세요. 실제로 바로 쓸 수 있는 지표.
  - 

#### UI 렌더링 이슈
  - 16ms 안에 뷰를 그려.
  - 3.0 이후 display 리스트 도입으로 viewRoot에 방문 필요 없음.
  - 4.0 에서 하드웨어 엑셀레이션 도입 / 
  - 딴소리 : 하드웨어 레이어 동시 사용 필수.
  - cpu/gpu 스로틀링

#### 스토리지
  - 4kb에 빠르다고 해서 256kb도 빠르지는 않다.
  - File IO할 떄 다른 앱이 File IO를 안쓴다는 보장이 없다.
  - 웨어 레벨링(메모리나 배터리는 계속 쓰면 닳아.)


## 4. 어댑터. 어떻게 접근하면 좋을까? : 권태환님

### ViewModel 이용하여 분리하기
 - 어댑터에서 아무것도 하지 않도록 하는게 목표.
 - 정승욱님이 블로그에 올렸던 Adapter, 누구냐 넌? 이라는 주제에서 출발.
 

 ### 어댑터의 구성
  - 뷰의 재사용을 하기 위한 구조.
  - 뷰홀더가 엄청나게 필요해질 수 있음. -> 수백줄의 코드 생산!

### 개선
 - 뷰홀더 각자가 처리하도록.
 - 어댑터는 onCreateViewHolder만 해주면 됨.

### mvp 분리가 가능한가?
 - ViewHolder : View를 그리는 역할만 담당.


### Viewmodel(Controller와 유사) 도입?
 - 어댑터에서 하는 일을 줄이고 싶다.
 - 그러다보니 결국 Viewmodel은 결국 Controller에 가까워진다.



