# 2018년 2월 2일 안드로이드 라이트닝 토크

## 1. Dagger2 라이트하게 훑어보기 : (http://www.github.com/pleasantlife)

## 2. Clean Architecture with socket.io

### Clean Architecture
 - 클린 아키텍처가 뭐게? : 구글에 검색해봐.
 
### 왜 클린 아키텍처를 사용하는가?
 - 내부에 들어갈 수록, 외부의 코드를 모르기 때문에. -> 테스트 용이, 순수한 코드 사용. 상호간 영향력 감소로 유지보수 용이. UI모듈이 독립적으로 분리되어 개선하기 쉬워짐.

### 클린 아키텍처의 규칙
 - 의존성 법칙 : 소프트웨어의 의존성은 항상 내부를 향해야 한다. (안에서는 밖의 코드를 모르게 하라!)

### socket.io
 ### 소켓이란.
 - 클라이언트와 서버의 커넥션이 맺어진 이후, 커넥션이 맺어진 모든 클라이언트들에게 서버가 이벤트를 보낼 수 있음.
 - 이렇게 되면, 스마트폰에서 리퀘스트를 해도 노트북이나 태블릿 등에서 리스폰스를 받을 수 있다.
 
 ### 왜 적용하기 어려운가?
 - 어렵다기 보다는 익숙하지 않기 때문.(restapi에 익숙한 우리들.)
 - socket.io 자체가 커넥트, 디스커넥트, 리커넥트 등을 직접 설정해줘야함.
 - 

 ### 적용 예시
 -


## 3. 뜯어고치기 쉽게 앱 뜯어고치기
 - Realm, Dagger, Rx 도입 시도 : 코드의 90%를 변경해야 하여 시간부족으로 실패.
 - OCR 베타 출시 & 머티리얼 디자인 가이드 적용 
 - 콴다 V2 출시 : 앱을 처음부터 끝까지 새로 작성 -> 선생님 앱 / 학생 앱 분리

 ### V2 출시를 하면서 돌아본 '지속관리 용이한 앱 만들기'
  - 재사용성, 의존성 제거, 모듈화
  - 안드로이드 클린 아키텍처가 도움이 되었다.

  - 최근 AAC Room이 뜨고 있다?
 
 ### 디자인 컴포넌트 정하기
  - 디자인 컴포넌트를 만드는 것을 고려.
  - 디자인 가이드 앱을 만드는 목적 : 안드로이드 기본 컴포넌트를 이해시키자 / 삼성폰과 lg폰 차이를 인지시키자.(특히 색감!) / SDK 버전에 따른 Style의 차이를 인지시키자 / Margin과 Padding을 이해시키자



## 3.

### 안드로이드 8.0의 변화
 - Dex 파일의 크기가 줄었음.
 - Concurrent Compaction 도입. 모든 앱에 세대적 가비지 컬렉션 도입. 가비지 컬렉터 포즈(pause) 타임 감소. 17.5배 성능 향상
 - 루프를 탈 필요가 없는 것들은 알아서 루프를 타지 않음.
 - 벡터라이제이션 도입.
 
### 품질확보
 - 크래시 리포트나 다종 테스트로는 조금 부족하다.(버벅거림 등)
 - 모든 계층을 모니터링 해야 한다.

 #### 메모리 관리
  - 한번 쓰고 말 객체는 WeakReference를 달아라.
  - 안드로이드 5.0부터 작은 객체와 큰 객체를 구분하여 저장함.
  - GC가 한번 동작하면, 1세대에서 많은 것들이 사라짐.
  - 안드로이드 L부터 gc전략 추가, Foreground / Background GC로 구성.
  - 왜 나눴을까? Foreground는 화면 등을 담당. 빠른 정리가 중요.
  - Oreo부터 Concurrent Compaction이 도입되는 이유? : 앱사이즈 감소, 멀티코어 디바이스 확대.
  - 다만, 제조사가 언제든 다른 옵션을 켤 수 있다.
  - 메모리 사용 지표 : MemFree보다 MemAvailable을 이용하세요. 실제로 바로 쓸 수 있는 지표.
  - 

#### UI 렌더링 이슈
  - 16ms 안에 뷰를 그려.
  - 3.0 이후 display 리스트 도입으로 viewRoot에 방문 필요 없음.
  - 4.0 에서 하드웨어 엑셀레이션 도입 / 
  - 딴소리 : 하드웨어 레이어 동시 사용 필수.
  - cpu/gpu 스로틀링

#### 스토리지
  - 4kb에 빠르다고 해서 256kb도 빠르지는 않다.
  - File IO할 떄 다른 앱이 File IO를 안쓴다는 보장이 없다.
  - 웨어 레벨링(메모리나 배터리는 계속 쓰면 닳아.)


## 4. 어댑터. 어떻게 접근하면 좋을까? : 권태환님

### ViewModel 이용하여 분리하기
 - 어댑터에서 아무것도 하지 않도록 하는게 목표.
 - 정승욱님이 블로그에 올렸던 Adapter, 누구냐 넌? 이라는 주제에서 출발.
 

 ### 어댑터의 구성
  - 뷰의 재사용을 하기 위한 구조.
  - 뷰홀더가 엄청나게 필요해질 수 있음. -> 수백줄의 코드 생산!

### 개선
 - 뷰홀더 각자가 처리하도록.
 - 어댑터는 onCreateViewHolder만 해주면 됨.

### mvp 분리가 가능한가?
 - ViewHolder : View를 그리는 역할만 담당.


### Viewmodel(Controller와 유사) 도입?
 - 어댑터에서 하는 일을 줄이고 싶다.
 - 그러다보니 결국 Viewmodel은 결국 Controller에 가까워진다.



